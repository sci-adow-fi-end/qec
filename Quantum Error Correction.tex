\documentclass{article}
\usepackage{graphicx}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{braket}
\usepackage{tikz}
\usepackage{float}
\usetikzlibrary{quantikz2}
\usepackage{pgfplots}
\pgfplotsset{compat=1.18}
\title{Quantum Error Correction Tecniques}
\author{Alessio Delli Colli}
\date{May 2024}

\newtheorem{Solovay-Kitaev}{Theorem (Solovay Kitaev 1997)}

\newtheorem{Prox-Universal-Set}{Theorem}
 
\begin{document}

\maketitle

\newpage

\tableofcontents

\newpage

\section{Introduction}

\vspace{10pt}

\subsection{The importance of quantum information}

\vspace{10pt}

Maintaining fundamental properties of important documents, like secrecy
and authenticity, through the process of digitalization has been one of the main
quests of the last decades. These qualities have been currently achieved mainly
by the route of clever mathematics, exploiting properties of our current com-
puting machines and especially the knowledge, although not yet crystal clear,
of what they can or can’t do in a reasonable time.
It is possible to find a relevant example of this in the RSA protocol, that uses
the difficulty of solving the factorization problem in available machines in order
to construct a cryptosystem and also a digital signature scheme wow.

\vspace{10pt}

While the metric of ”being difficult to compute” may seem arbitrary at first
glance, it is based on the solid theory of computational complexity.
Such theory, founded on the Church-Turing Thesis, aims to measure the com-
plexity of a problem in terms of the number of steps a Turing machine would
take to solve it.
More specifically, problems are said to be in the class P if there is a Turing
machine able to solve them in an amount of time that is a polynomial function
of the input size and are said to be in the class NP if there is a Turing machine
that can verify a guessed solution in a similar polynomial time.
The distinction between the classes P and NP has yet to be proved but it is
generally assumed that these classes are not coincident.

\vspace{10pt}

This conjecture leads to believe that there are some problems that belong to
the class NP but not to P so, for them, it is easy to verify if a configuration is
a solution but not to find one. For these problems isn’t thus possible to find a
solving algorithm that is substantially better than trying all the possible config-
urations and verifying them one by one until a solution is found. This approach
is known as an exhaustive search.
If we were able to test the configurations efficiently that would lead to the possi-
bility of constructing an algorithm that solves a problem without the knowledge
of its structure, but just utilizing an ”oracle” which is a routine that is able to
distinguish solutions from non solutions.
Such approach is called a Black-Box algorithm.
Unfortunately it is known that classical computation can’t make this kind of al-
gorithm efficient but maybe in another form of computation the outcome could
be different.

\newpage

In 1996 Lov Grover showed that with quantum computing it is possible to
complete an exhaustive search with only square root of n calls to the oracle,
where n is the size of the input. While this is an extraordinary result, later
studies have shown that it can’t be further improved.
This means that no Black-Box algorithm can solve a non polynomial problem
in polynomial time, even taking into consideration quantum computing.
Though, quantum computing can be much more significative when the algorithm
relies on the problem structure, as in the case of Shor’s algorithm.
The Shor’s algorithm aims to find a solution to the factorization problem by
doing a reduction to a simpler problem, at least from a quantum standpoint,
which is finding the order of an element in an abelian group. This problem is
then solved thanks to a procedure called Quantum Fourier Transform.
The whole procedure has a just above quadratic time complexity and so, it is
much faster than the better classical algorithm currently available which works
is a sub-exponential time.
The execution of this algorithm or it’s proper variants on a suitable hardware
could allow to break most of the cryptosystems used today, like DHM, ECDHM,
and the above mentioned RSA.

\vspace{20pt}


\subsection{The need for quantum error correction}

\vspace{10pt}

The applications described above although feasible for quantum computers require
very complex machines that are prone to errors.
This comes from the fact that larger machines have a tendency to bond to the
environment and this bonding makes them produce unpredictable results.
Such tendency has put a limit to the implementation of quantum algorithms.
An example of that could be that the largest number we have currently been
able to reliably factorize using the Shor algorithm is 21.
This seems rather underwhelming given the fact the numbers we aim to factorize
whit it are in the realm of $2^{2000}$.
Luckly there are techniques that allow us to catch and correct the errors
when they arise, before they can propagate uncontrollaby and improving
such tecniques will bring us closer to our goal.



\section{From quantum physics to quantum information}

To understand the technicalities behind the operations described above it is
necessary to dive in the phisical processes involved in them.\\
So will be done shortly in this section.

\newpage

\subsection{Foundations of quantum mechanics}

\subsubsection{Cinematic axioms}

\begin{enumerate}
	\item To each quantum system S corresponds an Hilbert space $H_S$.\\
	      The space of pure\footnote{The definition of pure state will
		      be given in the section 4}
	      states is identified by the projective space $P(H_S)$.

	\item Given two quantum systems $S_1$ and $S_2$ and their correspondent
	      Hilbert spaces $H_{S1}$ and $H_{S2}$ the space that characterizes the
	      compound system is $H_{S1} \otimes H_{S2}$, where $\otimes$ denotes
	      the tensor product.

	\item A measure procedure on a quantum state S is described
	      by a family \\  $M := \{M_\alpha \}_{\alpha\in A}$ where:

	      \begin{itemize}
		      \item $M_\alpha \in B(H_S) $ $ \forall \alpha \in A$
		      \item $A \subset \mathbb{R}$
		      \item $\sum_{\alpha \in A} M_\alpha^\dag M_\alpha = Id(H_S)$
	      \end{itemize}

	      Where B(Hs) is the set of bounded operators in $H_S$ and A is the
	      set of all the possible outcomes of the measure.\\
	      Given the outcome $\alpha_0 \in A$ and the state $\ket{\psi}$,
	      the probability
	      of measuring the output $\alpha_0$ being in the state $\ket{\psi}$
	      is:
	      \begin{center}
		      $P(\psi : \alpha_0) = \braket{\psi|M_{\alpha_0}^\dag M_{\alpha_0}\psi}$

	      \end{center}


	      \subsubsection{Dynamic axioms}


	\item Given a quantum system $S_1$ and two time instants$ t_1$ and $t_2$
	      with $t_1<=t_2$ there is an unique unitary operator$U(t_1,t_2)$ that
	      describes the evolution of the system between the time instants.

	      The unitary operator should respect also some additional
	      properties:\\
	      $
		      \begin{cases}
			      U(t_1,t_1) = Id(H_S) \\
			      U(t_2,t_3)U(t_1,t_2) = U(t_1,t_3)
		      \end{cases} $

	\item In the instant immediately after the measure
	      $M := \{M_\alpha \}_{\alpha\in A}$ is applied to the quantum
	      system S while being in the state $\ket{\psi}$ \\
	      the system will collapse to the state:

	      \begin{center}
		      $\dfrac{M_{\alpha_0}\ket\psi}
			      {\sqrt{\braket{\psi|M_{\alpha_0}^\dag M_{\alpha_0}\psi}}}$
	      \end{center}
\end{enumerate}


\subsection{Qubits}

Physical systems can be used to store information
but not all systems are practical for doing so. \\
In fact, if we wanted to represent some complex information we
could choose to use a single complex system that has many states,
but doing so it would be very difficult to prepare it for the
computation.\\
Suppose for example that we had a way of quickly giving energy
to the system to make it jump from one of its base states to
the next, and luckily we have it.\\
In the case of one single system to reach the n-Th base state
we would need n energy transfers, and that is quite unpractical.\\
Even more so if we consider than using multiple occurrences of
the simplest non trivial quantum system, that is the one that
has only 2 base states,\\ we would need at most $\log_2{n}$ transfers.\\
This simple quantum system is known as a qubit.\\

\subsection{Qubit representations and Probability amplitudes}

The state of a qubit can be represented in many ways.\\
Some useful representations are the unitary vectors in $\mathbb{C}^2$
and the points of a unitary sphere called the Block Sphere.
we are going to analyze each of them and their respective advantages.

\subsubsection{State vectors}

The state vector of a qubit consists in two components in $\mathbb{C}$
that can be interpreted as the probability amplitudes of each of the
base states.
The probability amplitude of a base state is a complex number that,
when taken the absolute value squared, gives the probability that the
above mentioned state will be the outcome
of a measure. %FIXME rivedere la fine


\subsubsection{The Bloch sphere}

\begin{center}
	\includegraphics[scale=0.5]{bloch-sphere.png}
\end{center}
The Bloch sphere gives us an useful graphical representation of a
qubit's state that is linked to the state vector by the following
isomorphism.\\

$\ket{\psi} = \cos{\dfrac{\theta}{2}}\ket{0}+e^{i\phi}\sin{\dfrac{\theta}{2}}\ket{1}$ \\

\vspace{10pt}
This representation is particularly advantagious because it allows
to visualize the evolution of a qubit over time in the execution
of a quantum algorithm.


\section{One qubit systems}


\subsection{Introduction to quantum gates}
Quantum states are not very interesting when they are static, \\
what we want to achieve is a way to make them evolve\\
and accurately control their evolution over time.
The element used in a quantum system in order to make it evolve
in a controlled way is called a quantum gate.\\
While in classical information there is just a single kind of one bit
gate in quantum information there are infinitely many!
In the next paragraph we will se the most important ones.

\newpage

\subsection{Some examples of one qubit gates}

\begin{itemize}

	\item Pauli Gates\\
	      can be seen as rotations on the three main axis of the bloch
	      sphere
	      \begin{center}
		      $	X:=\begin{bmatrix}
				      0 & 1 \\
				      1 & 0
			      \end{bmatrix}
			      \hspace{10pt}
			      Y:=\begin{bmatrix}
				      0 & -i \\
				      i & 0
			      \end{bmatrix}
			      \hspace{10pt}
			      Z:=\begin{bmatrix}
				      1 & 0  \\
				      0 & -1
			      \end{bmatrix}$
	      \end{center}


	\item Hadamard Gate\\
	      brings the state $\ket{0}$ to
	      $\ket{+} := \dfrac{\ket{0}+\ket{1}}{2}$
	      and the state $\ket{1}$ to $\ket{-} := \dfrac{\ket{0}-\ket{1}}{2}$
	      \begin{center}
		      $	H:=\dfrac{1}{\sqrt{2}}\begin{bmatrix}
				      1 & 1  \\
				      1 & -1
			      \end{bmatrix}$
	      \end{center}

	\item Phase Gate \\
	      changes the phase of a qubit arbitrarly
	      \begin{center}


		      $	P:=\begin{bmatrix}
				      1 & 0         \\
				      0 & e^{i\phi}
			      \end{bmatrix}$
	      \end{center}
\end{itemize}

\subsection{One qubit interference}




The reason why quantum algorithms can be faster than classical ones
in some tasks is because they can exploit some propreties of quantum
systems that classical systems lack. \\
One of these propreties is interference.\\
In quantum information interference is used to enhance the probability of
getting a favourable state at the end of the computation.\\
\vspace{10pt}
\begin{figure}[H]
	\centering
	\scalebox{1.5}{
		\begin{quantikz}
			\lstick{$\ket{0}$}\slice[style=blue, label style={pos=1, anchor=north}]{${\scriptstyle\ket{\psi_{t0}}}$}	& \gate{H}
			\slice[style=blue, label style={pos=1, anchor=north}]{${\scriptstyle\ket{\psi_{t1}}}$}	& \gate{P}
			\slice[style=blue, label style={pos=1, anchor=north}]{${\scriptstyle\ket{\psi_{t2}}}$}	& \gate{H}
			\slice[style=blue, label style={pos=1, anchor=north}]{${\scriptstyle\ket{\psi_{t3}}}$}	&
		\end{quantikz}
	}
	\caption{Ramsey interferometer}
	\label{interference}
\end{figure}
\vspace{10pt}
An example of this can be found in the circuit in Figure \ref{interference}.\\
The circuit, called Ramsey interferometer, can be modeled by two Hadamard gates with a phase gate
in between.\\
\newpage
Below is the time analisys of the circuit.
\begin{itemize}

	\item $\ket{\psi_{t0}} = \ket{0}$
	\item $\ket{\psi_{t1}} = \dfrac{\ket{0}+\ket{1}}{\sqrt{2}}$
	\item $\ket{\psi_{t2}} = \dfrac{\ket{0}+e^{i\phi}\ket{1}}{\sqrt{2}}$
	\item $\ket{\psi_{t3}} = \dfrac{\dfrac{\ket{0}+\ket{1}}{\sqrt{2}}+e^{i\phi}\dfrac{\ket{0}-\ket{1}}
		      {\sqrt{2}}}{\sqrt{2}}   = \dfrac{(1+e^{i\phi})\ket{0}+(1-e^{i\phi})\ket{1}}{2}$




\end{itemize}

\vspace{20pt}

So the probability of measuring $\ket{1}$ at the end is the module squared of it's\\
coefficient that is:\\
\vspace{10pt}

$\left|\dfrac{1-e^{i\phi}}{2}\right|^2 = \left(\dfrac{1-e^{i\phi}}{2}\right)\left(\dfrac{1-e^{-i\phi}}{2}\right) =$\\
\vspace{5pt}


$ = \dfrac{2-e^{i\phi}+e^{-i\phi}}{4} = \dfrac{2-2\cos{\phi}}{4} =$\\

\vspace{3pt}
$ = sin^2{\left(\dfrac{\phi}{2}\right)}$

\vspace{10pt}



\begin{figure}[H]
	\centering
	\scalebox{1}{
		\begin{tikzpicture}
			\begin{axis}[
					axis lines = middle,
					xlabel = $\phi$,
					ylabel = {$p(\ket{1}$)},
					ymin = 0,
					ymax = 1,
					xtick={-pi, -pi/2, 0, pi/2, pi}, % Positions of the x-ticks
					xticklabels={$-\pi$, $-\frac{\pi}{2}$, $0$, $\frac{\pi}{2}$, $\pi$}, % Labels for the x-ticks
					width=10cm, % Width of the plot
					height=4cm, % Height of the plot
					axis equal, % Ensure x and y units are the same length
				]
				\addplot[
					domain=-pi:pi,
					samples=100,
					color=blue,
				]
				{sin(deg(x))^2};
			\end{axis}
		\end{tikzpicture}
	}
	\caption{probability of measuring $\ket{1}$ for each value of $\phi$}
	\label{interferencegraph}
\end{figure}

It is possible to observe in Figure \ref{interferencegraph}
that the output of the measure on the qubit depends only on the
ammout of fase shift that has been inflicted
to the qubit, this can be seen as a manifestation of the phenomenon
of interferece.



\subsection{introduction to quantum universality}

We have seen that our previous circuit allows us to manipulate a qubit
in every possible way but that leaves us with a practical question.
Is it possible to realize it in practice?
The short answer to this question is no, but we can get very close.
To elaborate more this answer we need to introduce a few definitions
regarding quantum universality.
\begin{itemize}

	\item
	      a \textbf{Strictly universal} set of gates can generate every possible gate


	\item
	      a \textbf{Prox universal} set of gate can approximate every possible gate to
	      arbitrary precision


\end{itemize}

Unfortunately there isn't and can't be a finite and strictly universal
set of ports because the space of unitary operators in a
Hilbert space is continue while the possible combinations of
operators we can get from a finite set of them is just countable.\\
The proprety we can actually achieve in a real world circuit is
prox-universality.\\

\begin{Prox-Universal-Set}
The set of gates {H,T,C-Not} is prox universal.
\end{Prox-Universal-Set}

Knowing it is possible to make a circuit that arbitrarly approximates
every
single quantum gate what we could be interested in discovering is how
big that circuit would be.\\

That is known thanks to an amazing result by Solovay and Kitaev which
states
that the number of ports we need to aproximate a circuit with a certain
precision grows logaritmically with the precision we want to achieve.

\begin{Solovay-Kitaev}

Given a strictly universal set of gates S which is closed under inversion,
the number of gates needed to approximate every n qubit circuit made
from S whith precision $\epsilon$ is
$O\Bigl(n2^n+2^nlog_2 \Bigl( \dfrac{1}{\epsilon}\Bigl)\Bigl)$


\end{Solovay-Kitaev}


\newpage

\section{Many qubits systems and subsystems}



\subsection{Many qubit gates}
%FIXME whose?
It is possible to construct gates whose output is determined by the state
of many input qubits.
The most common example of this kind of gates are controlled not gates.
%TODO insert other examples


\subsection{Quantum entanglement}

It often happens using many qubit gates that the states of the output
qubits are no longer independent from each other so the probability
of measuring a possible result on one qubit depends on the states of
other qubits involved in the transformation.
In this case we called this "bonded" qubits entangled.
a clear example of this can be found in the circuit in Figure \ref{entanglement}.\\

\begin{figure}[H]
	\centering
	\scalebox{1.5}{
		\begin{quantikz}
			\lstick{$\ket{0}$}\slice[style=blue, label style={pos=1, anchor=north}]{${\scriptstyle\ket{\psi_{t0}}}$}	& \gate{H}
			\slice[style=blue, label style={pos=1, anchor=north}]{${\scriptstyle\ket{\psi_{t1}}}$}	 &\ctrl{1}&\\
			\lstick{$\ket{0}$}&& \targ{} \slice[style=blue, label style={pos=1, anchor=north}]{${\scriptstyle\ket{\psi_{t2}}}$}	&
		\end{quantikz}
	}
	\caption{Bell state generator}
	\label{entanglement}
\end{figure}

\begin{itemize}
	\item $\ket{\psi_{t0}} = \ket{0} \otimes \ket{0}$
	\item $\ket{\psi_{t1}} = \dfrac{\ket{0}+\ket{1}}{\sqrt{2}} \otimes \ket{0} = \dfrac{\ket{00}+\ket{10}}{\sqrt{2}}$
	\item $\ket{\psi_{t2}} = \dfrac{\ket{00}+\ket{11}}{\sqrt{2}}$

\end{itemize}
It can be observed that the final state of the circuit can't be split
in a tensor product of states.
Moreover it is one of the four Bell states.
Such states have the interesting proprety of constituting a base for all
the entangled states of two qubits.

\subsection{From system to subsystem}

When we study a quantum system we are not always interested in the
system
as a whole, sometimes we care only about a fraction of it.
Compartmentalizing the system if for sure easy and intuitive when it
is in a pure state, but can be more intricate when we are talking about
an entangled state.\\
In this latter case in fact we are not able to assign a state to the
subsystem that is independent from the rest of the original system
and we have to rely on the possibility of making statistical
predictions
about the outcomes of a measure on that subsystem.\\
To do it in a convenient way we use a special operator called density
operator.\\
It is very important in quantum computation because lets us describe
a not completely known ensamble of states.\\
Immagine for example we had a system that could be in each of the
states
$\ket{\psi_i}$ with probability $p_i$, we call $\{p_i,\ket{\psi_i}\}$ an
ensamble of pure states with an associate density operator
$\rho:=\sum_i p_i \ket{\psi_i}\bra{\psi_i} $


%TODO insert definition of density matrix.

\section{Representing uncertainty}


\subsection{Errors generate uncertainty}



\subsection{Uncertainty in quantum states}

\subsection{Uncertainty in quantum operations}

\section{Measuring errors}

\subsection{Static distance measures}

\subsection{Dynamic distance measures}

\section{Correcting errors}
c
\subsection{Brief introduction to classical error correction}

Correcting errors is an ancient problem that puzzled the minds of
information theorists long before the invention of quantum computation.
To achieve such task it is common to encode information in a subspace of
the space of messages that can be sent trough the channel to be able to
detect if a message has shifted away from this subspace because of an
error and, if possible, correct it.\\
A natural way of doing the above is using linear codes because they
enable a compact representation of the code itself.\\
A simple example of this concept is given by the three bit repetition
code.\\
To encode a message in this simple code we have to repeat each letter
or digit three times es: example $\rightarrow$ eeexxxaaammmpppllleee.\\
To decode a possible message we will choose from each triple the
letter that appears in the most occurences es peexxxaanmmmpppllleee $\rightarrow$ example. \\
If the channel introduces few errors we will often be able to recover
the initial message completely.
the problem with this simple code lies in the fact that it is not very
efficient in terms of space occupied by the encoded message.
Fourther developments of this idea brought us codes like the Hamming
codes and the Reed-Solomon codes which are widely used to this day.




\subsection{Quantum coding theory}

\subsection{Some examples of quantum codes}

\subsubsection{Quantum repetition codes}

\subsubsection{The Shor code}

\subsubsection{Degenerate codes}

\subsubsection{CSS codes}

\subsubsection{Stabilizer codes}




\end{document}
