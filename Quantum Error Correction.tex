\documentclass{article}
\usepackage{graphicx}
\usepackage{amsfonts}
\usepackage{braket}
\usepackage{amsmath}
\title{Quantum Error Correction Tecniques}
\author{Alessio Delli Colli}
\date{May 2024}

\newtheorem{Solovay-Kitaev}{Theorem (Solovay Kitaev 1997)}

\newtheorem{Prox-Universal-Set}{Theorem}
 
\begin{document}

\maketitle

\newpage

\tableofcontents

\newpage

\section{Introduction}

\vspace{10pt}

\subsection{The importance of quantum information}

\vspace{10pt}

Maintaining fundamental properties of important documents, like secrecy
and authenticity, through the process of digitalization has been one of the main
quests of the last decades. These qualities have been currently achieved mainly
by the route of clever mathematics, exploiting properties of our current com-
puting machines and especially the knowledge, although not yet crystal clear,
of what they can or can’t do in a reasonable time.
It is possible to find a relevant example of this in the RSA protocol, that uses
the difficulty of solving the factorization problem in available machines in order
to construct a cryptosystem and also a digital signature scheme.

\vspace{10pt}

While the metric of ”being difficult to compute” may seem arbitrary at first
glance, it is based on the solid theory of computational complexity.
Such theory, founded on the Church-Turing Thesis, aims to measure the com-
plexity of a problem in terms of the number of steps a Turing machine would
take to solve it.
More specifically, problems are said to be in the class P if there is a Turing
machine able to solve them in an amount of time that is a polynomial function
of the input size and are said to be in the class NP if there is a Turing machine
that can verify a guessed solution in a similar polynomial time.
The distinction between the classes P and NP has yet to be proved but it is
generally assumed that these classes are not coincident.

\vspace{10pt}

This conjecture leads to believe that there are some problems that belong to
the class NP but not to P so, for them, it is easy to verify if a configuration is
a solution but not to find one. For these problems isn’t thus possible to find a
solving algorithm that is substantially better than trying all the possible config-
urations and verifying them one by one until a solution is found. This approach
is known as an exhaustive search.
If we were able to test the configurations efficiently that would lead to the possi-
bility of constructing an algorithm that solves a problem without the knowledge
of its structure, but just utilizing an ”oracle” which is a routine that is able to
distinguish solutions from non solutions.
Such approach is called a Black-Box algorithm.
Unfortunately it is known that classical computation can’t make this kind of al-
gorithm efficient but maybe in another form of computation the outcome could
be different.

\newpage

In 1996 Lov Grover showed that with quantum computing it is possible to
complete an exhaustive search with only square root of n calls to the oracle,
where n is the size of the input. While this is an extraordinary result, later
studies have shown that it can’t be further improved.
This means that no Black-Box algorithm can solve a non polynomial problem
in polynomial time, even taking into consideration quantum computing.
Though, quantum computing can be much more significative when the algorithm
relies on the problem structure, as in the case of Shor’s algorithm.
The Shor’s algorithm aims to find a solution to the factorization problem by
doing a reduction to a simpler problem, at least from a quantum standpoint,
which is finding the order of an element in an abelian group. This problem is
then solved thanks to a procedure called Quantum Fourier Transform.
The whole procedure has a just above quadratic time complexity and so, it is
much faster than the better classical algorithm currently available which works
is a sub-exponential time.
The execution of this algorithm or it’s proper variants on a suitable hardware
could allow to break most of the cryptosystems used today, like DHM, ECDHM,
and the above mentioned RSA.

\vspace{20pt}


\subsection{The need for quantum error correction}

\vspace{10pt}

The applications described above although feasible for quantum computers require
very complex machines that are prone to errors.
This comes from the fact that larger machines have a tendency to bond to the
environment and this bonding makes them produce unpredictable results.
Such tendency has put a limit to the implementation of quantum algorithms.
An example of that could be that the largest number we have currently been
able to reliably factorize using the Shor algorithm is 21.
This seems rather underwhelming given the fact the numbers we aim to factorize
whit it are in the realm of $2^{2000}$.
Luckly there are techniques that allow us to catch and correct the errors
when they arise, before they can propagate uncontrollaby and improving
such tecniques will bring us closer to our goal.



\section{From quantum physics to quantum information}

To understand the technicalities behind the operations described above it is
necessary to dive in the phisical processes involved in them.\\
So will be done shortly in this section.

\newpage

\subsection{Foundations of quantum mechanics}

\subsubsection{Cinematic axioms}

\begin{enumerate}
    %TODO find a better s symbol
    \item To each quantum system S corresponds an Hilbert space $H_s$.\\
      The space of pure\footnote{The definition of pure state will
      be given in the section 4}
      states is identified by the projective space $P(H_s)$.

  \item Given two quantum systems $S_1$ and $S_2$ and their correspondent
    Hilbert spaces $H_{s1}$ and $H_{s2}$ the space that characterizes the
    compound system is $H_{s1} \otimes H_{s2}$, where $\otimes$ denotes
    the tensor product.

  \item A measure procedure on a quantum state S is described
    by a family \\  $M := \{M_\alpha \}_{\alpha\in A}$ where:

    \begin{itemize}
        \item $M_\alpha \in B(H_s) $ $ \forall \alpha \in A$
        \item $A \subset \mathbb{R}$
        \item $\sum_{\alpha \in A} M_\alpha^\dag M_\alpha = Id(H_s)$
    \end{itemize}

    Where B(Hs) is the set of bounded operators in $H_s$ and A is the
    set of all the possible outcomes of the measure.\\
    Given the outcome $\alpha_0 \in A$ and the state $\ket{\psi}$,
    the probability
    of measuring the output $\alpha_0$ being in the state $\ket{\psi}$
    is: 
    \begin{center}
      $P(\psi : \alpha_0) = \braket{\psi|M_{\alpha_0}^\dag M_{\alpha_0}\psi}$
      
    \end{center}

    
\subsubsection{Dynamic axioms}


\item Given a quantum system $S_1$ and two time instants$ t_1$ and $t_2$
  with $t_1<=t_2$ there is an unique unitary operator$U(t_1,t_2)$ that
  describes the evolution of the system between the time instants.

  The unitary operator should respect also some additional
  properties:\\
    $
    \begin{cases}
        U(t_1,t_1) = Id(H_s)\\
        U(t_2,t_3)U(t_1,t_2) = U(t_1,t_3)
    \end{cases} $ 

  \item In the instant immediately after the measure
    $M := \{M_\alpha \}_{\alpha\in A}$ is applied to the quantum
    system S while being in the state $\ket{\psi}$ \\
    the system will collapse to the state:
    
    \begin{center}
      $\dfrac{M_{\alpha_0}\ket\psi}
      {\sqrt{\braket{\psi|M_{\alpha_0}^\dag M_{\alpha_0}\psi}}}$
    \end{center}
\end{enumerate}


\subsection{Qubits}

Physical systems can be used to store information
but not all systems are practical for doing so. \\
In fact, if we wanted to represent some complex information we
could choose to use a single complex system that has many states,
but doing so it would be very difficult to prepare it for the
computation.\\
Suppose for example that we had a way of quickly giving energy
to the system to make it jump from one of its base states to
the next, and luckily we have it.\\
In the case of one single system to reach the n-Th base state
we would need n energy transfers, and that is quite unpractical.\\
Even more so if we consider than using multiple occurrences of
the simplest non trivial quantum system, that is the one that
has only 2 base states,\\ we would need at most $\log_2{n}$ transfers.\\
This simple quantum system is known as a qubit.\\

\subsection{Qubit representations and Probability amplitudes}

The state of a qubit can be represented in many ways.\\
Some useful representations are the unitary vectors in $\mathbb{C}^2$
and the points of a unitary sphere called the Block Sphere.
we are going to analyze each of them and their respective advantages.

\subsubsection{State vectors}

The state vector of a qubit consists in two components in $\mathbb{C}$
that can be interpreted as the probability amplitudes of each of the
base states.
The probability amplitude of a base state is a complex number that,
when squared, gives the probability that that state will be the outcome
of a measure in the computational base. %FIXME rivedere la fine

\subsubsection{The Bloch sphere}

The Bloch sphere gives us an useful graphical representation of a
qubit's state that is linked to the state vector by the following
isomorphism.\\
% TODO insert isomorphism.
This representation is particularly advantagious because it allows
to visualize the evolution of a qubit over time in the execution
of a quantum algorithm.

\newpage

\section{One qubit systems}


\subsection{Introduction to quantum gates}
Quantum states are not very interesting when they are static, \\
what we want to achieve is a way to make them evolve\\
and accurately control their evolution over time.
The element used in a quantum system in order to make it evolve
in a controlled way is called a quantum gate.\\
While in classical information there is just a single kind of one bit
gate in quantum information there are infinitely many!
In the next paragraph we will se the most important ones.

\subsection{Some examples of one qubit gates}

\begin{itemize}

  %TODO insert matrix and definition of every port
\item
  Pauli Gates

\item
  Hadamard Gate
  
\item
  Phase Gates
  
\end{itemize}

\subsection{one qubit interference}

%TODO insert immage 

The reason why quantum algorithms can be faster than classical ones
in some tasks is because they can exploit some propreties of quantum
systems that classical systems lack.\\
One of these propreties is interference.\\
In quantum information interference is used to control the final
state of our system.\\
An example of this can be found in the circuit in Figure 1.
The circuit consists in two Hadamard gates with a phase gate
in between.\\
Below is the time analisys of the system.
\begin{itemize}

\item $\ket{\psi_{t0}} = \ket{0}$
\item $\ket{\psi_{t1}} = \dfrac{\ket{0}+\ket{1}}{\sqrt{2}}$
\item $\ket{\psi_{t2}} = \dfrac{\ket{0}+e^{\phi}\ket{1}}{\sqrt{2}}$
\item $\ket{\psi_{t0}} = \ket{0}$
  
  
\end{itemize}


%TODO insert graph of measure

It is possible to observe that the output of the measure on the qubit
depends only on the ammout of fase shift that has been inflicted
to the qubit.



\subsection{introduction to quantum universality}

We have seen that our previous circuit allows us to manipulate a qubit
in every possible way but that leaves us with a practical question.
Is it possible to realize it in practice?
The short answer to this question is no, but we can get very close.
To elaborate more this answer we need to introduce a few definitions
regarding quantum universality.
\begin{itemize}

\item
  Strict universality
  %TODO insert definition

\item
  Prox universality
  %TODO insert definition

\end{itemize}

Unfortunately there isn't and can't be a finite set of strictly
universal
ports because of the fact that the space of unitary operators in a
Hilbert space is continue while the possible combinations of
operators we can get from a finite set of them is just countable.\\
The proprety we can actually achieve in a real world circuit is
prox-universality.\\

\begin{Prox-Universal-Set}
The set of gates {H,T,C-Not} is prox universal.
\end{Prox-Universal-Set}

Knowing it is possible to make a circuit that arbitrarly approximates
every
single quantum gate what we could be interested in discovering is how
big that circuit would be.\\

That is known thanks to an amazing result by Solovay and Kitaev which
states
that the number of ports we need to aproximate a circuit with a certain
precision grows logaritmically with the precision we want to achieve.
  
\begin{Solovay-Kitaev}

  Given a strictly universal set of gates S which is closed under inversion,
  the number of gates needed to approximate every n qubit circuit made
  from S whith precision $\epsilon$ is
  $O\Bigl(n2^n+2^nlog_2 \Bigl( \dfrac{1}{\epsilon}\Bigl)\Bigl)$
  

\end{Solovay-Kitaev}


\newpage

\section{Many qubits systems and subsystems}



\subsection{many qubit gates}

\subsection{quantum entanglement}

%TODO insert image

\subsection{from system to subsystem}

When we study a quantum system we are not always interested in the
system
as a whole, sometimes we care only about a fraction of it.
Compartmentalizing the system if for sure easy and intuitive when it
is in a pure state, but can be more intricate when we are talking about
an entangled state.\\
In this latter case in fact we are not able to assign a state to the
subsystem that is independent from the rest of the original system
and we have to rely on the possibility of making statistical
predictions
about the outcomes of a measure on that subsystem.\\
To do it in a convenient way we use a special operator called density
operator.\\
It is very important in quantum computation because lets us describe
a not completely known ensamble of states.\\
Immagine for example we had a system that could be in each of the
states
$\ket{\psi_i}$ with probability $p_i$, we call $\{p_i,\ket{\psi_i}\}$ an
ensamble of pure states with an associate density operator
$\rho:=\sum_i p_i \ket{\psi_i}\bra{\psi_i} $


%TODO insert definition of density matrix.

\section{Representing uncertainty}

\subsection{Errors generate uncertainty}

 

\subsection{Uncertainty in quantum states}

\subsection{Uncertainty in quantum operations}

\section{Measuring errors}

\subsection{Static distance measures}

\subsection{Dynamic distance measures}

\section{Correcting errors}
c
\subsection{Brief introduction to classical error correction}

Correcting errors is an ancient problem that puzzled the minds of
information theorists long before the invention of quantum computation.

\subsection{Quantum repetition codes}

\end{document}
